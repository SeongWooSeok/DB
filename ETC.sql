-- INDEX 인덱스(INDEX)'는 데이터가 위치한 장소의 정보를 가진 일종의 주소록
CREATE INDEX EMP_INDEX
ON EMP(EMPNO, ENAME);
DROP INDEX EMP_INDEX;

--DICTIONARY 데이터 사전(Data Dictionary)이란 대부분 읽기 전용으로 제공되는 테이블 및 뷰들의 집합
SELECT * FROM DICT;
SELECT * FROM DICTIONARY
WHERE TABLE_NAME LIKE 'USER%';
/*USER__? 사용자 관련 객체정보
ALL_?? 사용자 사용가능한 객체정보
DBA_?? DB관련 정보(SYSTEM SYS)
V$_?? VIEW 관련*/

SELECT *FROM USER_TABLES;
SELECT * FROM ALL_TABLES WHERE OWNER='SCOTT';
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_USERS;
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;
SELECT * FROM OBJ;

--VIEW VIEW란 기존의 존재하는 테이블로 만들어진 가상의 테이블이라고 정의할 수 있다.
DROP VIEW VW_EMP2;
CREATE VIEW VW_EMP2
AS ( SELECT E.*,D.DNAME, D.LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO);

SELECT * FROM USER_VIEWS;
SELECT * FROM VW_EMP2;

/*
SEQUENCE
CREATE SEQUENCE [SEQ NAME]
INCREMENT BY [NUM]
START WITH [START NUM]
NOMINVALUE OR MINVALUE [MINNUM]
NOMINVALUE OR MAXVALUE [MAXNUM]
CYCLE OR NOCYCLE
CACHSE OR NOCACHE
*/
DROP SEQUENCE EX_SEQ;
CREATE SEQUENCE EX_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 1000
NOCYCLE
NOCACHE;

CREATE TABLE SEQTABLE(SEQNUM NUMBER(4),TESTTXT VARCHAR2(10));
SELECT * FROM SEQTABLE;
INSERT INTO SEQTABLE VALUES(EX_SEQ.NEXTVAL,'TEST TEXT');
SELECT EX_SEQ.CURRVAL FROM DUAL;
SELECT EX_SEQ.NEXTVAL FROM DUAL;
ALTER SEQUENCE EX_SEQ INCREMENT BY -2;

/*줄번호*/
SELECT ROWNUM,A.*
FROM(
    SELECT E.*
    FROM EMP E
    ORDER BY E.ENAME
) A
ORDER BY A.JOB;

--분석함수를 사용할 때 PARTITION BY를 사용하여 그룹으로 묶어서 연산을 할 수 있다.
SELECT ROW_NUMBER() OVER(PARTITION BY E.JOB ORDER BY E.JOB, E.ENAME) ROW_NUM
            ,E.*
FROM EMP E
ORDER BY E.JOB, E.ENAME;

SELECT EMPNO, ENAME, DEPTNO, JOB, SUM(SAL) OVER(PARTITION BY JOB, DEPTNO)
FROM EMP
WHERE JOB IN('MANAGER', 'SALESMAN')
ORDER BY JOB, DEPTNO;

--RANK는 공동2등이 두명이면 다음사람을 3등이라고 안하고 4등이라고 하지만 DENSERANK는 3등으로 나옴
SELECT EMPNO,ENAME, JOB, SAL, RANK() OVER(ORDER BY SAL DESC) AS 등수
            ,DENSE_RANK() OVER(ORDER BY SAL DESC) AS 등수2
FROM EMP
WHERE SAL IS NOT NULL
ORDER BY SAL DESC;

/*
SYNONYM 동의어 
    CREATE PUBLIC SYNONYM [NAME]
    FOR [TARGET]
    실제로 SYNONYM을 이용하는 이유는 다른 유저의 객체를 사용할 때 
    유저의 이름과 객체의 실제 이름을 사용하는데,  그 두 개를 감춤으로써 
    데이터베이스의 보안을 개선하기 위해 사용된다.
*/
CREATE SYNONYM DE
FOR DEPT;
SELECT * FROM DE;
DROP SYNONYM DE;

--Q1
DROP TABLE EMPIDX;
CREATE TABLE EMPIDX
AS SELECT * FROM EMP;
--EMPIDX 테이블의 EMPNO값을 기준으로 한 인덱스 IDX_EMPIDX_EMPNO 생성
CREATE INDEX IDX_EMPIDX_EMPNO
ON EMPIDX(EMPNO);
DROP INDEX IDX_EMPIDX_EMPNO;

SELECT * FROM USER_INDEXES WHERE INDEX_NAME='IDX_EMPIDX_EMPNO';

--Q2 급여가 1500을 넘는 사람의 사번 이름 직급 급여를 
--      담은 뷰 EMPIDX_OVER15를 생성
--CREATE OR REPLACE 생성하거나 있으면 바꿈
CREATE OR REPLACE VIEW EMPIDX_OVER15
AS ( SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E
WHERE SAL<1500);
DROP VIEW EMPIDX_OVER15;
SELECT * FROM USER_VIEWS WHERE VIEW_NAME='EMPIDX_OVER15';
SELECT * FROM EMPIDX_OVER15;

--Q3
DROP TABLE DEPTSEQ;
CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
--SEQ_DEPTSEQ 시퀀스를 생성(1에서 99까지 1씩 증가 순환없음 캐쉬 안씀)
CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 99
NOCYCLE
NOCACHE;
--SEQ_DEPTSEQ 시퀀스 삭제
DROP SEQUENCE SEQ_DEPTSEQ;

--SEQ_DEPTSEQ 시퀀스를 생성(10에서 100까지 60부터 10씩 증가 순환없음 캐쉬안씀)
CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 1
START WITH 60
MINVALUE 10
MAXVALUE 100
CYCLE
NOCACHE;
--ALTER SEQUENCE SEQ_DEPTSEQ INCREMENT BY 10;

--UNION
SELECT * FROM EMP WHERE DEPTNO=10
UNION
SELECT * FROM EMP WHERE DEPTNO=20;

SELECT * FROM EMP WHERE DEPTNO=20
UNION ALL
SELECT * FROM EMP WHERE DEPTNO=20
UNION ALL
SELECT * FROM EMP WHERE DEPTNO=20;

/*
    계층형 쿼리
    START WITH [CONDITION]
    CONNECT BY PRIOR[CONDITION]
*/
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, B.EMPNO, B.ENAME, B.JOB
FROM EMP A, EMP B
WHERE A.MGR=B.EMPNO;

SELECT LEVEL, EMPNO, ENAME, MGR, JOB
FROM EMP
START WITH JOB='PRESIDENT'
CONNECT BY PRIOR EMPNO=MGR AND LEVEL<=2;
 
/*숫자찍기*/
SELECT * FROM(SELECT ROWNUM NUM FROM EMP E, EMP A) WHERE NUM<=24;

SELECT * FROM(
    SELECT 1 AS DUAL FROM DUAL UNION ALL
    SELECT 2 FROM DUAL UNION ALL
    SELECT 3 FROM DUAL UNION ALL
    SELECT 4 FROM DUAL UNION ALL 
    SELECT 5 FROM DUAL UNION ALL
    SELECT 6 FROM DUAL
    );

SELECT LEVEL FROM DUAL
CONNECT BY LEVEL<=24;